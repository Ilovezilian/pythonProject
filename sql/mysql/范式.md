# 数据库范式
[如何解释关系数据库的第一第二第三范式？ - 刘慰的回答 - 知乎](https://www.zhihu.com/question/24696366/answer/29189700)

* 范式：一张数据表的表结构所符合的某种设计标准的级别
* 数据库范式也分为1NF，2NF，3NF，BCNF，4NF，5NF。
* 一般在我们设计关系型数据库的时候，最多考虑到BCNF就够。符合高一级范式的设计，必定符合低一级范式，例如符合2NF的关系模式，必定符合1NF。

## 第一范式（1NF）
**符合1NF的关系中的每个属性都不可再分**

## 第二范式（2NF）
* **2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖。**
* 接下来对这句话中涉及到的四个概念——“函数依赖”、“码”、“非主属性”、与“部分函数依赖”进行一下解释。

### 函数依赖
我们可以这么理解（但并不是特别严格的定义）：若在一张表中，在属性（或属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说Y函数依赖于X，写作 X → Y。
* 完全函数依赖
    在一张表中，若 X → Y，且对于 X 的任何一个真子集（假如属性组 X 包含超过一个属性的话），X ' → Y 不成立，那么我们称 Y 对于 X 完全函数依赖，记作 X F→ Y。（那个F应该写在箭头的正上方)
* 部分函数依赖
    假如 Y 函数依赖于 X，但同时 Y 并不完全函数依赖于 X，那么我们就称 Y 部分函数依赖于 X，记作 X P→ Y
* 传递函数依赖
    假如 Z 函数依赖于 Y，且 Y 函数依赖于 X （感谢 百达 指出的错误，这里改为：『Y 不包含于 X，且 X 不函数依赖于 Y』这个前提），那么我们就称 Z 传递函数依赖于 X ，记作 X T→ Z

### 码
设 K 为某表中的一个属性或属性组，若除 K 之外的所有属性都完全函数依赖于 K（这个“完全”不要漏了），那么我们称 K 为候选码，简称为码。在实际中我们通常可以理解为：假如当 K 确定的情况下，该表除 K 之外的所有属性的值也就随之确定，那么 K 就是码。一张表中可以有超过一个码。（实际应用中为了方便，通常选择其中的一个码作为主码）

## 第三范式（3NF）
**3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖。**

## BCNF范式
**每个表都只有一个候选主键**

## 总之
1. 1NF：字段是最小的的单元不可再分 -- 属性不可分割
1. 2NF：满足1NF,表中的字段必须完全依赖于全部主键而非部分主键 (一般我们都会做到) -- 要有主键，要求其他字段都依赖于主键 -- 消除非主属性对键的部分依赖
1. 3NF：满足2NF,非主键外的所有字段必须互不依赖 -- 消除非主属性传递依赖
1. BCNF:满足3NF，消去主属性对键的传递函数依赖
1. 4NF：满足3NF,消除表中的多值依赖
1. 5NF：从最终结构重新建立原始结构


